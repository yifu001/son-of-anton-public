---
phase: 01-bug-fixes
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/classes/terminal.class.js
autonomous: true

must_haves:
  truths:
    - "World view globe shows actual geolocated endpoint when online"
    - "Globe displays real network connections as pins"
    - "File browser tracks terminal CWD on Windows"
    - "CWD updates within 500ms of directory change"
  artifacts:
    - path: "src/classes/terminal.class.js"
      provides: "Windows CWD tracking via PowerShell"
      contains: "Windows_NT"
    - path: "src/classes/locationGlobe.class.js"
      provides: "Real connection display (no code change needed)"
  key_links:
    - from: "src/classes/terminal.class.js"
      to: "child_process.exec"
      via: "PowerShell CWD query"
      pattern: "powershell"
    - from: "src/classes/locationGlobe.class.js"
      to: "window.mods.netstat.offline"
      via: "online status check"
      pattern: "netstat.offline"
---

<objective>
Fix globe mock data fallback (FIX-01) and Windows CWD tracking (FIX-03)

Purpose:
- FIX-01: Globe shows mock San Francisco data because netstat.offline was true. With Plan 01 complete, netstat now correctly reports online status, so globe should automatically work. Verification needed.
- FIX-03: File browser shows "TRACKING FAILED" on Windows because _getTtyCWD has no Windows case. Need to add Windows support using PowerShell.

Output: Modified terminal.class.js with Windows CWD support; verified globe displays real data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bug-fixes/01-RESEARCH.md
@.planning/phases/01-bug-fixes/01-01-SUMMARY.md
@src/classes/terminal.class.js
@src/classes/locationGlobe.class.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Windows CWD tracking to terminal.class.js</name>
  <files>src/classes/terminal.class.js</files>
  <action>
Add Windows case to the _getTtyCWD method (lines 320-346).

The challenge: On Windows, node-pty spawns a shell process (PowerShell/cmd), but the PID we have is for the pty host, not the shell itself. We need to find the shell's child process and get its working directory.

Add this Windows case before the `default` case (around line 341):

```javascript
case "Windows_NT":
    // On Windows, we need to find the shell child process of node-pty
    // and query its working directory
    const psScript = `
        $ptyPid = ${pid}
        # Find child processes of the pty
        $children = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ptyPid }
        if ($children) {
            # Get the first child (the shell)
            $shellPid = $children[0].ProcessId
            # Get the working directory of the shell
            $proc = Get-Process -Id $shellPid -ErrorAction SilentlyContinue
            if ($proc) {
                # Use .NET to get current directory - works for cmd.exe and powershell
                try {
                    $handle = [System.Diagnostics.Process]::GetProcessById($shellPid)
                    # For PowerShell/cmd, check the MainModule path and infer from there
                    # Actually use WMI to get the command line which often contains the cwd
                    $wmiProc = Get-CimInstance Win32_Process -Filter "ProcessId=$shellPid"
                    if ($wmiProc.ExecutablePath) {
                        # Parse CWD from environment - this is tricky
                        # Fallback: use the parent directory of the executable
                        Write-Output (Split-Path $wmiProc.ExecutablePath -Parent)
                    }
                } catch {
                    Write-Output ""
                }
            }
        }
    `.replace(/\n/g, ' ');

    // Simpler approach: parse the prompt from terminal output
    // But that's unreliable. Better approach: use cmd /c cd or powershell $PWD

    // Actually, the most reliable Windows approach is to inject a command
    // But that's invasive. Let's use a simpler WMI query approach:

    require("child_process").exec(
        `powershell -NoProfile -Command "` +
        `$children = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq ${pid} }; ` +
        `if ($children) { ` +
        `  $shellPid = $children[0].ProcessId; ` +
        `  $cwd = (Get-CimInstance Win32_Process -Filter \\"ProcessId=$shellPid\\").ExecutablePath; ` +
        `  if ($cwd) { Split-Path $cwd -Parent } ` +
        `}"`,
        { timeout: 2000 },
        (e, stdout) => {
            if (e !== null) {
                reject(e);
            } else {
                let cwd = stdout.trim();
                if (cwd) {
                    resolve(cwd);
                } else {
                    reject(new Error("Could not determine CWD"));
                }
            }
        }
    );
    break;
```

IMPORTANT: The above approach gets the executable path, not the shell's current working directory. A more reliable approach for Windows:

REVISED IMPLEMENTATION - Use a simpler, proven approach:

```javascript
case "Windows_NT":
    // Find the shell child process and its current working directory
    // This uses a two-step WMI query
    const cmd = `powershell -NoProfile -Command "` +
        // Step 1: Find child process of pty (the shell)
        `$child = Get-CimInstance Win32_Process | ` +
        `Where-Object { $_.ParentProcessId -eq ${pid} } | ` +
        `Select-Object -First 1; ` +
        // Step 2: Get working directory using handle
        `if ($child) { ` +
        `  try { ` +
        `    $p = [System.Diagnostics.Process]::GetProcessById($child.ProcessId); ` +
        `    $p.StartInfo.WorkingDirectory ` +
        `  } catch { ` +
        `    $child.ExecutablePath | Split-Path -Parent ` +
        `  } ` +
        `}"`;

    require("child_process").exec(cmd, { timeout: 2000 }, (e, stdout) => {
        if (e !== null) {
            reject(e);
        } else {
            let cwd = stdout.trim();
            if (cwd && cwd.length > 0) {
                resolve(cwd);
            } else {
                // Fallback: try to get initial cwd
                reject(new Error("Windows CWD tracking not available"));
            }
        }
    });
    break;
```

NOTE: Windows shell CWD tracking is inherently difficult. If the above doesn't work reliably, implement prompt parsing as fallback (Task 2).
  </action>
  <verify>
1. No syntax errors on app load
2. _getTtyCWD resolves (not rejects) on Windows
3. Some CWD value returned (even if not perfectly accurate yet)
  </verify>
  <done>
- Windows_NT case added to _getTtyCWD switch statement
- PowerShell command executes without error
- Returns a directory path (may need refinement)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Windows CWD via prompt parsing fallback</name>
  <files>src/classes/terminal.class.js</files>
  <action>
The WMI approach from Task 1 may not reliably get the shell's CURRENT directory (it gets startup directory). Implement prompt parsing as a more reliable Windows solution.

Windows prompts typically look like:
- cmd.exe: `C:\Users\name\project>`
- PowerShell: `PS C:\Users\name\project>`

Add a prompt parsing mechanism:

1. Add a property to track last seen CWD from prompt (in server role constructor, around line 318):
```javascript
this._windowsCwdFromPrompt = null;
this._lastPromptMatch = 0;
```

2. Add prompt parser method after _getTtyCWD:
```javascript
_parseWindowsCwdFromOutput = (data) => {
    // Match Windows prompt patterns
    // cmd.exe: "C:\path\to\dir>"
    // PowerShell: "PS C:\path\to\dir>"
    const patterns = [
        /^PS ([A-Z]:\\[^>]*?)>\s*$/m,           // PowerShell
        /^([A-Z]:\\[^>]*?)>\s*$/m,              // cmd.exe
        /^PS ([A-Z]:\\[^>]*?)> $/m,             // PowerShell with trailing space
    ];

    for (const pattern of patterns) {
        const match = data.match(pattern);
        if (match && match[1]) {
            return match[1].trim();
        }
    }
    return null;
};
```

3. In the tty.onData handler (around line 468), add prompt detection for Windows:
```javascript
this.tty.onData(data => {
    this._nextTickUpdateTtyCWD = true;
    this._nextTickUpdateProcess = true;

    // Windows: Parse CWD from prompt
    if (require("os").type() === "Windows_NT") {
        const parsed = this._parseWindowsCwdFromOutput(data);
        if (parsed && parsed !== this._windowsCwdFromPrompt) {
            this._windowsCwdFromPrompt = parsed;
            if (this.renderer) {
                this.renderer.send("terminal_channel-" + this.port, "New cwd", parsed);
            }
        }
    }

    try {
        ws.send(data);
    } catch (e) {
        // Websocket closed
    }
});
```

4. Update _getTtyCWD Windows case to use cached prompt CWD:
```javascript
case "Windows_NT":
    // Use CWD parsed from prompt if available
    if (this._windowsCwdFromPrompt) {
        resolve(this._windowsCwdFromPrompt);
    } else {
        // Fall back to initial cwd
        reject(new Error("Waiting for prompt-based CWD detection"));
    }
    break;
```

This approach is more reliable because:
- It captures the actual shell working directory
- Updates immediately when user runs `cd` command
- Works with both cmd.exe and PowerShell
  </action>
  <verify>
1. Run `cd` command in terminal
2. File browser path updates within 500ms
3. Works with both cmd.exe and PowerShell shells
  </verify>
  <done>
- Prompt parsing extracts CWD from terminal output
- File browser updates when directory changes
- CWD tracking works without "TRACKING FAILED" message
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify globe displays real data (FIX-01)</name>
  <files>src/classes/locationGlobe.class.js</files>
  <action>
With Plan 01 complete (netstat.offline now correctly false on Windows), the globe should automatically work. This task verifies the fix without code changes.

Verification procedure:

1. Start the app: `npm start` (with Node 16)

2. Check netstat status in DevTools console:
```javascript
window.mods.netstat.offline    // Must be false
window.mods.netstat.ipinfo     // Must have ip and geo properties
window.mods.netstat.ipinfo.geo // Must have latitude and longitude
```

3. Check globe is using real data:
```javascript
// In locationGlobe.class.js, updateLoc() checks window.mods.netstat.offline
// If false, it calls updateConOnlineConnection() which uses real ipinfo.geo
window.mods.globe.lastgeo  // Should have real coordinates, not 37.7749, -122.4194
```

4. Visual verification:
- Globe header shows real coordinates (not "37.7749, -122.4194 (MOCK)")
- Globe pins/markers appear at your actual geographic location
- Network connections appear as globe animates

IF globe still shows mock data despite netstat.offline being false:
- Check console for errors in updateConOnlineConnection()
- Verify ipinfo.geo is populated before globe tries to access it
- May need to add null check or retry logic

Potential fix if timing issue exists (add to locationGlobe.class.js if needed):
```javascript
// In updateLoc(), add retry if ipinfo not ready
updateLoc() {
    if (window.mods.netstat.offline) {
        this.updateWithMockData();
    } else if (!window.mods.netstat.ipinfo || !window.mods.netstat.ipinfo.geo) {
        // ipinfo not ready yet, retry in 1 second
        setTimeout(() => this.updateLoc(), 1000);
    } else {
        this.updateConOnlineConnection().then(() => {
            document.querySelector("div#mod_globe").setAttribute("class", "");
        }).catch(() => {
            this.updateWithMockData();
        });
    }
}
```
  </action>
  <verify>
1. `window.mods.netstat.offline === false` in console
2. Globe header shows coordinates different from mock (37.7749, -122.4194)
3. Globe shows connections at your actual location
  </verify>
  <done>
- Globe displays real geolocated endpoint
- No "(MOCK)" suffix in coordinates display
- Network connections appear as pins on globe
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

**FIX-01 (Globe) Verification:**
1. Globe header shows real coordinates (not mock San Francisco)
2. `window.mods.globe.lastgeo.latitude !== 37.7749` in console
3. Network connection pins appear on globe

**FIX-03 (CWD) Verification:**
1. Open terminal in app
2. Run: `cd C:\Users` (or any directory)
3. File browser path updates within 500ms
4. No "TRACKING FAILED" message in file browser

Manual test command:
```bash
nvm use 16
cd C:/Users/yzuo2/OneDrive/Desktop/yifuzuo/projects/edex-ui
npm start
```

DevTools console checks:
```javascript
// FIX-01 verification
window.mods.netstat.offline === false
window.mods.globe.lastgeo.latitude !== 37.7749

// FIX-03 verification
// Run cd command in terminal, check file browser updates
```
</verification>

<success_criteria>
1. **FIX-01:** Globe shows actual geolocated coordinates based on external IP lookup
2. **FIX-01:** Network connections display as pins on globe (ESTABLISHED connections)
3. **FIX-03:** File browser CWD updates within 500ms when terminal directory changes
4. **FIX-03:** No "TRACKING FAILED" message on Windows
5. **FIX-03:** Works with both cmd.exe and PowerShell terminals
</success_criteria>

<output>
After completion, create `.planning/phases/01-bug-fixes/01-02-SUMMARY.md`
</output>
